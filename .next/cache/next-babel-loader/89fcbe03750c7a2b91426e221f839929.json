{"ast":null,"code":"import _objectSpread from \"@babel/runtime-corejs2/helpers/esm/objectSpread\";\nimport convert from \"convert-seconds-to-human\"; // List Of animes Types\n\nconst types = [\"TV\", \"MOVIE\", \"TV_SHORT\", \"ONA\", \"OVA\", \"MUSIC\", \"SPECIAL\"];\nconst months = [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"];\n\nconst animeDate = date => {\n  const day = date.day ? date.day : \"\";\n  return `${months[date.month - 1]} ${day}, ${date.year}`;\n};\n\nconst animeEpisode = (nextAiringEpisode, episodes) => {\n  // check if Next episode exists or not\n  const checkEp = nextAiringEpisode ? nextAiringEpisode.episode : \"??\"; // check Total Episodes\n\n  const totalEp = episodes !== null ? episodes : \"??\";\n  return `Episode ${checkEp} of ${totalEp} in`;\n}; // get remainingTime for next epiosde\n\n\nconst remainingTime = sec => {\n  // convert seconds to date\n  const {\n    days,\n    hours,\n    minutes\n  } = convert(sec, \"cal\"); // check Text content;\n\n  const day = days > 1 ? \"days\" : \"day\";\n  const hour = hours > 1 ? \"hours\" : \"hour\";\n  const min = minutes > 1 ? \"mins\" : \"min\";\n  let timeCount = \"\";\n\n  if (days > 0 && hours > 0) {\n    // 10 Days, 10 hours\n    timeCount = `${days} ${day}, ${hours} ${hour}`;\n  } else if (days > 0 && hours === 0) {\n    // 13 Days, 14 minutes\n    timeCount = `${days} ${day}, ${minutes} ${min}`;\n  } else if (days === 0 && hours > 0) {\n    // 24 hours, 10 minutes\n    timeCount = `${hours} ${hour}, ${minutes} ${min}`;\n  } else {\n    // 14 minutes\n    timeCount = `${minutes} ${min}`;\n  }\n\n  return timeCount;\n};\n\nconst formatAnime = anime => {\n  let newAnime = _objectSpread({}, anime);\n\n  const {\n    startDate,\n    nextAiringEpisode,\n    episodes,\n    status,\n    rankings\n  } = anime;\n  const rank = rankings.length > 0 ? rankings[rankings.length - 1].rank : '';\n\n  switch (status) {\n    case \"FINISHED\":\n      newAnime.formatTime = animeDate(startDate);\n      newAnime.formatEpiosde = `${episodes} Ep aired on`;\n      break;\n\n    case \"RELEASING\":\n      // Check if  NextAiringEpisode not null\n      const checkAiring = nextAiringEpisode ? remainingTime(nextAiringEpisode.timeUntilAiring) : animeDate(startDate);\n      newAnime.formatTime = checkAiring;\n      newAnime.formatEpiosde = animeEpisode(nextAiringEpisode, episodes);\n      break;\n\n    case \"NOT_YET_RELEASED\":\n      newAnime.formatEpiosde = 'NOT YET RELEASED';\n      newAnime.formatTime = animeDate(startDate);\n      break;\n\n    default:\n      newAnime.formatTime = '??';\n      newAnime.formatEpiosde = '??';\n      break;\n  }\n\n  const isStudio = anime.studios ? anime.studios.nodes[0] : {};\n  newAnime.formatRank = rank;\n  newAnime.formatStudio = isStudio;\n  return newAnime;\n};\n\nexport const animesByType = animes => {\n  // create new list of each anime type\n  let newAnimeList = {};\n\n  for (let type of types) {\n    newAnimeList[type] = [];\n  }\n\n  for (let anime of animes) {\n    const type = anime.format; // add anime to arr based on type\n\n    newAnimeList[type].push(formatAnime(anime));\n  }\n\n  return newAnimeList;\n}; // Get Curr Season \n\nexport const getSeason = () => {\n  const date = new Date();\n  const month = date.getMonth();\n\n  if (month < 3) {\n    return 'WINTER';\n  } else if (month < 6) {\n    return 'SPRING';\n  } else if (month < 9) {\n    return 'SUMMER';\n  } else {\n    return 'FALL';\n  }\n\n  ;\n};","map":{"version":3,"sources":["I:\\AnimeChart\\animechart\\helpers\\animeHelper.js"],"names":["convert","types","months","animeDate","date","day","month","year","animeEpisode","nextAiringEpisode","episodes","checkEp","episode","totalEp","remainingTime","sec","days","hours","minutes","hour","min","timeCount","formatAnime","anime","newAnime","startDate","status","rankings","rank","length","formatTime","formatEpiosde","checkAiring","timeUntilAiring","isStudio","studios","nodes","formatRank","formatStudio","animesByType","animes","newAnimeList","type","format","push","getSeason","Date","getMonth"],"mappings":"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","sourcesContent":["import convert from \"convert-seconds-to-human\";\r\n\r\n// List Of animes Types\r\nconst types = [\"TV\", \"MOVIE\", \"TV_SHORT\", \"ONA\", \"OVA\", \"MUSIC\", \"SPECIAL\"];\r\nconst months = [\r\n  \"Jan\",\r\n  \"Feb\",\r\n  \"Mar\",\r\n  \"Apr\",\r\n  \"May\",\r\n  \"Jun\",\r\n  \"Jul\",\r\n  \"Aug\",\r\n  \"Sep\",\r\n  \"Oct\",\r\n  \"Nov\",\r\n  \"Dec\"\r\n];\r\n\r\nconst animeDate = date => {\r\n  const day = date.day ? date.day : \"\";\r\n  return `${months[date.month - 1]} ${day}, ${date.year}`;\r\n};\r\n\r\nconst animeEpisode = (nextAiringEpisode, episodes) => {\r\n  // check if Next episode exists or not\r\n  const checkEp = nextAiringEpisode ? nextAiringEpisode.episode : \"??\";\r\n  // check Total Episodes\r\n  const totalEp = episodes !== null ? episodes : \"??\";\r\n  return `Episode ${checkEp} of ${totalEp} in`;\r\n};\r\n\r\n// get remainingTime for next epiosde\r\nconst remainingTime = sec => {\r\n  // convert seconds to date\r\n  const { days, hours, minutes } = convert(sec, \"cal\");\r\n\r\n  // check Text content;\r\n  const day = days > 1 ? \"days\" : \"day\";\r\n  const hour = hours > 1 ? \"hours\" : \"hour\";\r\n  const min = minutes > 1 ? \"mins\" : \"min\";\r\n\r\n  let timeCount = \"\";\r\n  if (days > 0 && hours > 0) {\r\n    // 10 Days, 10 hours\r\n    timeCount = `${days} ${day}, ${hours} ${hour}`;\r\n  } else if (days > 0 && hours === 0) {\r\n    // 13 Days, 14 minutes\r\n    timeCount = `${days} ${day}, ${minutes} ${min}`;\r\n  } else if (days === 0 && hours > 0) {\r\n    // 24 hours, 10 minutes\r\n    timeCount = `${hours} ${hour}, ${minutes} ${min}`;\r\n  } else {\r\n    // 14 minutes\r\n    timeCount = `${minutes} ${min}`;\r\n  }\r\n  return timeCount;\r\n};\r\n\r\nconst formatAnime = anime => {\r\n  let newAnime = { ...anime };\r\n  const { startDate, nextAiringEpisode, episodes, status,rankings } = anime;\r\n   \r\n  const rank = rankings.length > 0 ? rankings[rankings.length - 1].rank :'';\r\n\r\n  switch (status) {\r\n    case \"FINISHED\":\r\n      newAnime.formatTime = animeDate(startDate);\r\n      newAnime.formatEpiosde = `${episodes} Ep aired on`;\r\n      break;\r\n    case \"RELEASING\":\r\n      // Check if  NextAiringEpisode not null\r\n      const checkAiring = nextAiringEpisode\r\n        ? remainingTime(nextAiringEpisode.timeUntilAiring)\r\n        : animeDate(startDate);\r\n      newAnime.formatTime = checkAiring;\r\n      newAnime.formatEpiosde = animeEpisode(nextAiringEpisode, episodes);\r\n      break;\r\n    case \"NOT_YET_RELEASED\":\r\n      newAnime.formatEpiosde = 'NOT YET RELEASED'\r\n      newAnime.formatTime = animeDate(startDate);\r\n      break;\r\n    default:\r\n      newAnime.formatTime = '??'\r\n      newAnime.formatEpiosde = '??'\r\n      break;\r\n  }\r\n  const isStudio = anime.studios ? anime.studios.nodes[0] : {};\r\n  newAnime.formatRank = rank;\r\n  newAnime.formatStudio = isStudio;\r\n  return newAnime;\r\n};\r\n\r\nexport const animesByType = animes => {\r\n  // create new list of each anime type\r\n  let newAnimeList = {};\r\n\r\n  for (let type of types) {\r\n    newAnimeList[type] = [];\r\n  }\r\n  for (let anime of animes) {\r\n    const type = anime.format;\r\n    // add anime to arr based on type\r\n    newAnimeList[type].push(formatAnime(anime));\r\n  }\r\n  return newAnimeList;\r\n};\r\n\r\n\r\n\r\n// Get Curr Season \r\n\r\nexport const getSeason  = () =>{\r\n  const date = new Date();\r\n  const month = date.getMonth();\r\n  if(month < 3){\r\n    return 'WINTER'\r\n  }else if(month < 6){\r\n    return 'SPRING'\r\n  }else if(month <9){\r\n    return 'SUMMER'\r\n  } else{\r\n    return 'FALL'\r\n  };\r\n}"]},"metadata":{},"sourceType":"module"}