{"ast":null,"code":"import _getIterator from \"@babel/runtime-corejs2/core-js/get-iterator\";\nimport _objectSpread from \"@babel/runtime-corejs2/helpers/esm/objectSpread\";\nimport convert from \"convert-seconds-to-human\"; // List Of animes Types\n\nvar types = [\"TV\", \"MOVIE\", \"TV_SHORT\", \"ONA\", \"OVA\", \"MUSIC\", \"SPECIAL\"];\nvar months = [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"];\n\nvar animeDate = function animeDate(date) {\n  var day = date.day ? date.day : \"\";\n  return \"\".concat(months[date.month - 1], \" \").concat(day, \", \").concat(date.year);\n};\n\nvar animeEpisode = function animeEpisode(nextAiringEpisode, episodes) {\n  // check if Next episode exists or not\n  var checkEp = nextAiringEpisode ? nextAiringEpisode.episode : \"??\"; // check Total Episodes\n\n  var totalEp = episodes !== null ? episodes : \"??\";\n  return \"Episode \".concat(checkEp, \" of \").concat(totalEp, \" in\");\n}; // get remainingTime for next epiosde\n\n\nvar remainingTime = function remainingTime(sec) {\n  // convert seconds to date\n  var _convert = convert(sec, \"cal\"),\n      days = _convert.days,\n      hours = _convert.hours,\n      minutes = _convert.minutes; // check Text content;\n\n\n  var day = days > 1 ? \"days\" : \"day\";\n  var hour = hours > 1 ? \"hours\" : \"hour\";\n  var min = minutes > 1 ? \"mins\" : \"min\";\n  var timeCount = \"\";\n\n  if (days > 0 && hours > 0) {\n    // 10 Days, 10 hours\n    timeCount = \"\".concat(days, \" \").concat(day, \", \").concat(hours, \" \").concat(hour);\n  } else if (days > 0 && hours === 0) {\n    // 13 Days, 14 minutes\n    timeCount = \"\".concat(days, \" \").concat(day, \", \").concat(minutes, \" \").concat(min);\n  } else if (days === 0 && hours > 0) {\n    // 24 hours, 10 minutes\n    timeCount = \"\".concat(hours, \" \").concat(hour, \", \").concat(minutes, \" \").concat(min);\n  } else {\n    // 14 minutes\n    timeCount = \"\".concat(minutes, \" \").concat(min);\n  }\n\n  return timeCount;\n};\n\nvar formatAnime = function formatAnime(anime) {\n  var newAnime = _objectSpread({}, anime);\n\n  var startDate = anime.startDate,\n      nextAiringEpisode = anime.nextAiringEpisode,\n      episodes = anime.episodes,\n      status = anime.status,\n      rankings = anime.rankings;\n  var rank = rankings.length > 0 ? rankings[rankings.length - 1].rank : '';\n\n  switch (status) {\n    case \"FINISHED\":\n      newAnime.formatTime = animeDate(startDate);\n      newAnime.formatEpiosde = \"\".concat(episodes, \" Ep aired on\");\n      break;\n\n    case \"RELEASING\":\n      // Check if  NextAiringEpisode not null\n      var checkAiring = nextAiringEpisode ? remainingTime(nextAiringEpisode.timeUntilAiring) : animeDate(startDate);\n      newAnime.formatTime = checkAiring;\n      newAnime.formatEpiosde = animeEpisode(nextAiringEpisode, episodes);\n      break;\n\n    case \"NOT_YET_RELEASED\":\n      newAnime.formatEpiosde = 'NOT YET RELEASED';\n      newAnime.formatTime = animeDate(startDate);\n      break;\n\n    default:\n      newAnime.formatTime = '??';\n      newAnime.formatEpiosde = '??';\n      break;\n  }\n\n  var isStudio = anime.studios ? anime.studios.nodes[0] : {};\n  newAnime.formatRank = rank;\n  newAnime.formatStudio = isStudio;\n  return newAnime;\n};\n\nexport var animesByType = function animesByType(animes) {\n  // create new list of each anime type\n  var newAnimeList = {};\n\n  for (var _i = 0, _types = types; _i < _types.length; _i++) {\n    var type = _types[_i];\n    newAnimeList[type] = [];\n  }\n\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = _getIterator(animes), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var anime = _step.value;\n      var _type = anime.format; // add anime to arr based on type\n\n      newAnimeList[_type].push(formatAnime(anime));\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n        _iterator[\"return\"]();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  return newAnimeList;\n}; // Get Curr Season \n\nexport var getSeason = function getSeason() {\n  var date = new Date();\n  var month = date.getMonth();\n\n  if (month < 3) {\n    return 'WINTER';\n  } else if (month < 6) {\n    return 'SPRING';\n  } else if (month < 9) {\n    return 'SUMMER';\n  } else {\n    return 'FALL';\n  }\n\n  ;\n};","map":{"version":3,"sources":["I:\\AnimeChart\\animechart\\helpers\\animeHelper.js"],"names":["convert","types","months","animeDate","date","day","month","year","animeEpisode","nextAiringEpisode","episodes","checkEp","episode","totalEp","remainingTime","sec","days","hours","minutes","hour","min","timeCount","formatAnime","anime","newAnime","startDate","status","rankings","rank","length","formatTime","formatEpiosde","checkAiring","timeUntilAiring","isStudio","studios","nodes","formatRank","formatStudio","animesByType","animes","newAnimeList","type","format","push","getSeason","Date","getMonth"],"mappings":"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","sourcesContent":["import convert from \"convert-seconds-to-human\";\r\n\r\n// List Of animes Types\r\nconst types = [\"TV\", \"MOVIE\", \"TV_SHORT\", \"ONA\", \"OVA\", \"MUSIC\", \"SPECIAL\"];\r\nconst months = [\r\n  \"Jan\",\r\n  \"Feb\",\r\n  \"Mar\",\r\n  \"Apr\",\r\n  \"May\",\r\n  \"Jun\",\r\n  \"Jul\",\r\n  \"Aug\",\r\n  \"Sep\",\r\n  \"Oct\",\r\n  \"Nov\",\r\n  \"Dec\"\r\n];\r\n\r\nconst animeDate = date => {\r\n  const day = date.day ? date.day : \"\";\r\n  return `${months[date.month - 1]} ${day}, ${date.year}`;\r\n};\r\n\r\nconst animeEpisode = (nextAiringEpisode, episodes) => {\r\n  // check if Next episode exists or not\r\n  const checkEp = nextAiringEpisode ? nextAiringEpisode.episode : \"??\";\r\n  // check Total Episodes\r\n  const totalEp = episodes !== null ? episodes : \"??\";\r\n  return `Episode ${checkEp} of ${totalEp} in`;\r\n};\r\n\r\n// get remainingTime for next epiosde\r\nconst remainingTime = sec => {\r\n  // convert seconds to date\r\n  const { days, hours, minutes } = convert(sec, \"cal\");\r\n\r\n  // check Text content;\r\n  const day = days > 1 ? \"days\" : \"day\";\r\n  const hour = hours > 1 ? \"hours\" : \"hour\";\r\n  const min = minutes > 1 ? \"mins\" : \"min\";\r\n\r\n  let timeCount = \"\";\r\n  if (days > 0 && hours > 0) {\r\n    // 10 Days, 10 hours\r\n    timeCount = `${days} ${day}, ${hours} ${hour}`;\r\n  } else if (days > 0 && hours === 0) {\r\n    // 13 Days, 14 minutes\r\n    timeCount = `${days} ${day}, ${minutes} ${min}`;\r\n  } else if (days === 0 && hours > 0) {\r\n    // 24 hours, 10 minutes\r\n    timeCount = `${hours} ${hour}, ${minutes} ${min}`;\r\n  } else {\r\n    // 14 minutes\r\n    timeCount = `${minutes} ${min}`;\r\n  }\r\n  return timeCount;\r\n};\r\n\r\nconst formatAnime = anime => {\r\n  let newAnime = { ...anime };\r\n  const { startDate, nextAiringEpisode, episodes, status,rankings } = anime;\r\n   \r\n  const rank = rankings.length > 0 ? rankings[rankings.length - 1].rank :'';\r\n\r\n  switch (status) {\r\n    case \"FINISHED\":\r\n      newAnime.formatTime = animeDate(startDate);\r\n      newAnime.formatEpiosde = `${episodes} Ep aired on`;\r\n      break;\r\n    case \"RELEASING\":\r\n      // Check if  NextAiringEpisode not null\r\n      const checkAiring = nextAiringEpisode\r\n        ? remainingTime(nextAiringEpisode.timeUntilAiring)\r\n        : animeDate(startDate);\r\n      newAnime.formatTime = checkAiring;\r\n      newAnime.formatEpiosde = animeEpisode(nextAiringEpisode, episodes);\r\n      break;\r\n    case \"NOT_YET_RELEASED\":\r\n      newAnime.formatEpiosde = 'NOT YET RELEASED'\r\n      newAnime.formatTime = animeDate(startDate);\r\n      break;\r\n    default:\r\n      newAnime.formatTime = '??'\r\n      newAnime.formatEpiosde = '??'\r\n      break;\r\n  }\r\n  const isStudio = anime.studios ? anime.studios.nodes[0] : {};\r\n  newAnime.formatRank = rank;\r\n  newAnime.formatStudio = isStudio;\r\n  return newAnime;\r\n};\r\n\r\nexport const animesByType = animes => {\r\n  // create new list of each anime type\r\n  let newAnimeList = {};\r\n\r\n  for (let type of types) {\r\n    newAnimeList[type] = [];\r\n  }\r\n  for (let anime of animes) {\r\n    const type = anime.format;\r\n    // add anime to arr based on type\r\n    newAnimeList[type].push(formatAnime(anime));\r\n  }\r\n  return newAnimeList;\r\n};\r\n\r\n\r\n\r\n// Get Curr Season \r\n\r\nexport const getSeason  = () =>{\r\n  const date = new Date();\r\n  const month = date.getMonth();\r\n  if(month < 3){\r\n    return 'WINTER'\r\n  }else if(month < 6){\r\n    return 'SPRING'\r\n  }else if(month <9){\r\n    return 'SUMMER'\r\n  } else{\r\n    return 'FALL'\r\n  };\r\n}"]},"metadata":{},"sourceType":"module"}